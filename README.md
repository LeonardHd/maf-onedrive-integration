# maf-onedrive-integration

A FastAPI demo application that lets users sign in with their Microsoft account,
browse OneDrive / SharePoint files, and generate **AI-powered summaries** of
documents—all from the browser.

## What This Demo Delivers

* **OAuth 2.0 sign-in** — Authorization Code flow with Azure AD, tokens stored
  server-side.
* **OneDrive / SharePoint browser** — navigate folders, view file metadata,
  and open files on the web.
* **AI file summarization** — select any file and get a concise summary
  generated by an LLM (GitHub Models) via the
  [Microsoft Agent Framework](https://github.com/microsoft/agent-framework)
  and [markitdown](https://github.com/microsoft/markitdown) for file-to-Markdown
  conversion.
* **CLI download script** — bulk-download files from a SharePoint document
  library to disk.

### Tech Stack

| Layer | Technology |
|---|---|
| Web framework | FastAPI + Uvicorn |
| Graph SDK | `msgraph-sdk` (async) |
| Identity | `azure-identity` · `AuthorizationCodeCredential` |
| AI agent | Microsoft Agent Framework (`agent-framework`) |
| File → Markdown | `markitdown[all]` |
| LLM backend | GitHub Models (OpenAI-compatible endpoint) |
| Frontend | Vanilla HTML / CSS / JS (served as a static file) |

## Authentication

This application needs delegated access to Microsoft Graph (OneDrive / SharePoint) on behalf of a signed-in user. There are two viable OAuth 2.0 flows for this, and the choice depends on where the token acquisition happens.

### Option 1 — Authorization Code Flow (current implementation)

The backend drives the entire OAuth exchange:

1. The user clicks **Sign in** and is redirected to Azure AD's `/authorize` endpoint.
2. Azure AD redirects back to `/auth/callback` with an **authorization code**.
3. The backend redeems the code for tokens using `azure.identity.AuthorizationCodeCredential` (which also handles token refresh transparently).
4. The credential object is stored **server-side** in a dict keyed by a random session ID. Only that session ID is written into an encrypted cookie via Starlette's `SessionMiddleware`.

Because the tokens never leave the server, this is the more secure option and the recommended pattern when the frontend is a server-rendered or backend-served page (as is the case here — `index.html` is served by FastAPI as a static file).

**Trade-off:** the backend must maintain a session store (`_credentials` dict today, Redis / a database in production) so it can map cookies back to credentials. Scaling horizontally requires a shared session store or sticky sessions.

```
Browser                  FastAPI backend              Azure AD
  │                           │                          │
  │  GET /login               │                          │
  │ ────────────────────────> │                          │
  │  302 → authorize URL      │                          │
  │ <──────────────────────── │                          │
  │                           │                          │
  │  User authenticates       │                          │
  │ ─────────────────────────────────────────────────>   │
  │  302 → /auth/callback?code=…                         │
  │ <─────────────────────────────────────────────────   │
  │                           │                          │
  │  GET /auth/callback       │                          │
  │ ────────────────────────> │                          │
  │                           │  POST /token (code)      │
  │                           │ ────────────────────-->  │
  │                           │  access + refresh token  │
  │                           │ <──────────────────────  │
  │                           │                          │
  │  Set-Cookie: session_id   │  store credential by sid │
  │ <──────────────────────── │                          │
```

### Option 2 — On-Behalf-Of (OBO) Flow

If the frontend were turned into a true **Single-Page Application** (SPA) that acquires its own tokens (e.g. using MSAL.js), the architecture would shift:

1. The SPA uses MSAL.js to sign the user in and obtain an **access token** scoped to the backend's API (a custom scope such as `api://<backend-client-id>/access_as_user`).
2. Every API call to the FastAPI backend includes that token in the `Authorization: Bearer …` header.
3. The backend validates the incoming token and then exchanges it for a **Microsoft Graph token** using the [OBO flow](https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-on-behalf-of-flow) (`ConfidentialClientApplication.acquire_token_on_behalf_of` in MSAL Python).
4. The Graph token is used to call OneDrive / SharePoint APIs on behalf of the user.

**Trade-off:** no server-side session store is needed (the SPA manages its own token cache), but the access token is exposed to the browser. The backend's Azure AD app registration must expose an API and configure the `knownClientApplications` / `api` permissions accordingly.

```
Browser (SPA + MSAL.js)        FastAPI backend              Azure AD
  │                                 │                          │
  │  MSAL.js acquireTokenSilent     │                          │
  │ ──────────────────────────────────────────────────────-->  │
  │  access token (audience=backend)│                          │
  │ <────────────────────────────────────────────────────────  │
  │                                 │                          │
  │  GET /api/files                 │                          │
  │  Authorization: Bearer <token>  │                          │
  │ ──────────────────────────────> │                          │
  │                                 │  OBO: exchange token     │
  │                                 │  for Graph access token  │
  │                                 │ ────────────────────-->  │
  │                                 │  Graph access token      │
  │                                 │ <──────────────────────  │
  │                                 │                          │
  │  JSON response                  │  call Graph API          │
  │ <────────────────────────────── │                          │
```

### Which to choose?

| Concern | Auth Code (Option 1) | OBO (Option 2) |
|---|---|---|
| Token location | Server only | Browser + server |
| Session store required | Yes | No |
| Frontend complexity | Minimal (static HTML) | Higher (MSAL.js, token management) |
| Horizontal scaling | Needs shared sessions | Stateless backend |
| Azure AD registration | Standard web app | Expose an API + configure OBO |

This project currently implements **Option 1** because the frontend is a simple static page served by the backend.

## Prerequisites

- Python 3.12+
- [uv](https://docs.astral.sh/uv/) package manager
- An Azure AD app registration (see below)
- A **GitHub personal access token** (PAT) with access to
  [GitHub Models](https://github.com/marketplace/models) — required for the
  summarization feature. You can obtain one with `gh auth token` (GitHub CLI)
  or from *GitHub → Settings → Developer settings → Personal access tokens*.

## Azure AD App Registration

1. Go to the [Azure Portal → App registrations](https://portal.azure.com/#view/Microsoft_AAD_RegisteredApps/ApplicationsListBlade) and click **New registration**.
2. Set a name (e.g. *MAF OneDrive Browser*).
3. Under **Redirect URIs**, add `http://localhost:8000/auth/callback` (type *Web*).
4. After creation, go to **Certificates & secrets → New client secret** and copy the value.
5. Under **API permissions**, add the following **Delegated** Microsoft Graph
   permissions:
   - `User.Read` — read the signed-in user's profile.
   - `Files.Read.All` — read files in OneDrive and SharePoint.
   - `Sites.Read.All` — list and read SharePoint sites.
6. Click **Grant admin consent** (or let each user consent individually).

Copy the **Application (client) ID** and the **Client secret value** — you will
put them in the `.env` file.

## Configuration

```bash
cp .env.example .env
```

Edit `.env` with your Azure AD credentials and GitHub Models token:

```dotenv
# Azure AD (required)
APPLICATION_ID=<your-application-client-id>
APPLICATION_SECRET=<your-client-secret>
TENANT_ID=common                                   # or a specific tenant ID
REDIRECT_URI=http://localhost:8000/auth/callback
SESSION_SECRET=<random-string>

# GitHub Models – AI summarization (required for /api/summarize)
GITHUB_TOKEN=<your-github-personal-access-token>
GITHUB_MODELS_MODEL_ID=gpt-4o-mini                 # optional, defaults to gpt-4o-mini
```

> **Note:** The summarization endpoint will return an error if `GITHUB_TOKEN` is
> missing or invalid. The rest of the application (browsing, downloading) works
> without it.

## Setup

```bash
# Install uv (if not already installed)
curl -LsSf https://astral.sh/uv/install.sh | sh

# Clone and sync (installs all dependencies including dev tools)
git clone <repo-url> && cd maf-onedrive-integration
uv sync --all-extras
```

## Running the Web Application

```bash
uv run maf-onedrive-web
# or
uv run uvicorn maf_onedrive_integration.app:app --reload
```

Then open <http://localhost:8000> in your browser, sign in with your Microsoft
account, and browse your OneDrive files.

## Development

### Install dev dependencies

```bash
uv sync --all-extras
```

### Linting & formatting

```bash
uv run ruff check .          # lint
uv run ruff format .         # auto-format
```

### Type checking

```bash
uv run ty check
```

### Testing

```bash
uv run pytest                # run all tests
uv run pytest -v             # verbose output
```

### Pre-commit hooks

```bash
uv run pre-commit install    # install hooks (once)
uv run pre-commit run --all-files  # run manually
```

The hooks run **ruff** (lint + format) and basic file checks (trailing
whitespace, YAML/TOML validity) on every commit.

## API Endpoints

| Method | Path | Description |
|---|---|---|
| `GET` | `/` | Serve the single-page frontend |
| `GET` | `/login` | Redirect to Azure AD sign-in |
| `GET` | `/auth/callback` | OAuth 2.0 authorization-code callback |
| `GET` | `/logout` | Clear session and sign out |
| `GET` | `/api/me` | Return the signed-in user's display name |
| `GET` | `/api/sites` | List SharePoint sites the user follows |
| `GET` | `/api/files` | List files / folders (`path`, `drive_id`, `site_id` query params) |
| `POST` | `/api/summarize` | Download a file and return an AI-generated summary (`item_id` required; optional `drive_id`, `site_id`) |

All `/api/*` endpoints return JSON and require an active session (HTTP 401 otherwise).

## Downloading Files (CLI script)

The included sample script authenticates with `DefaultAzureCredential` and
downloads all files from a SharePoint document library folder to your local
machine. Configure the SharePoint variables in `.env`:

```dotenv
SHAREPOINT_HOSTNAME=contoso.sharepoint.com
SHAREPOINT_SITE_PATH=/sites/my-team
ONEDRIVE_FOLDER_PATH=General
DOWNLOAD_DIR=./downloads
```

Then run:

```bash
uv run python -m maf_onedrive_integration.onedrive.sample_download
```

> **Note:** The CLI script uses `DefaultAzureCredential` (not the browser-based
> OAuth flow), so you need to be signed in via `az login` or have appropriate
> environment credentials configured.
